#AREA Builder~
#AUTHORS Scandum~
#VERSION 4
#RANGES 95 95 95 95


#HELPS
95 OLC~
{138}
  OLC

{128}  (A) {058}Alias List
{128}  (B) {058}Guidelines
{128}  (C) {058}Builder Agreements
{128}  (D) {058}Grammar
{128}  (E) {058}Builder Documentation

{128}  (-) {058}Return
{a}OLCALIAS
{b}OLCGUIDELINES
{c}OLCTERMS
{d}GRAMMAR
{e}BUILDER
{-}BUILDER
~

95 OLCALIAS~
{138}
                                 Alias List
{300}
alias oload   load obj %
alias mload   load mob %
alias check   edit area check %
alias redit   edit room %
alias medit   edit mob  %
alias oedit   edit obj  %
alias hedit   edit help %
alias aedit   edit area %
alias sedit   edit shop %
alias rdelete edit room delete %
alias mdelete edit mob  delete %
alias odelete edit obj  delete %
alias hdelete edit help delete %
alias rcreate edit room create %
alias mcreate edit mob  create %
alias ocreate edit obj  create %
alias hcreate edit help create %
alias mprog   prog mob  %
alias oprog   prog obj  %
alias mstat   stat mob  %
alias ostat   stat obj  %
alias rstat   stat room %
alias owhere  show owhere %
alias mwhere  show mwhere %
alias mlist   show mlist %
alias olist   show olist %
alias rlist   show rlist %
~

95 OLCGUIDELINES~
{118}*{178}Guidelines
 
{118}*{078}Don't walk around in other builder's areas without their permission.
{118}*{078}Don't be annoying
{118}*{078}Don't write programs that might harm the test mud's performance or crash it.
{118}*{078}Don't use mpcommands or programs to enhance your immortal powers

{118}*{078}The area's theme must fit in with the general Medieval, Fantasy, Tolkien
 based theme of the mud.
{118}*{078}Do not make references to the real world where possible, a few minor hints
 or jokes in that direction are acceptable.
{118}*{078}Write descriptive descriptions, where the main focus should always be to
 describe the room, object or mobile in question, and not any actions taking
 place in it, or emotions that go through the reader. Try to avoid using
 lines like 'A horrifying orc is here.' since that'd be a human point of view,
 and someone playing an undead character would in theory be unable to be
 scared. We suggest descriptions ranging from 3 to 5 lines of text.  If you
 do not enjoy writing them, it's okay to keep them plain and simple, maybe
 somewhat boring, as long as you use proper english and grammar.
{118}*{078}The area should have at least 1 good quest. If possible multiple quests.
 Also it's suggested to add some fun stuff, to liven things up, but don't
 make the mobs overly spamming.
{118}*{078}The area shouldn't be a leveling machine, this means that the mobs
 shouldn't be lined up waiting to be butchered. You must enter some sort of
 element of surprise, or another obstacle in it. This includes limitting
 the amount of mobiles. In general it's suggested to let your level mobs
 walk around.
 
{118}*{178}In order for your area to make it to the real game, the above mentioned
 qualities will be measured against it.
~

95 OLCTERMS~
{138}
                             Builder Agreements
{300}
{118}* {078}When creating an area for Lowlands you agree that Lowlands has
{118}  {078}the right to use and modify the area as we see fit.
{118}  {078}
{118}* {078}You also understand and agree that Lowland is unable to provide
{118}  {078}copies of area files to their creators.
~

95 GRAMMAR~
{138}
        GRAMMAR RULES FOR THE UNENLIGHTENED; OR, HOW TO WRITE GOODLY
{300}
Don't use no double negatives Don't never use no triple negatives. No sentence
fragments Corollary: Complete sentences: important. Stamp out and eliminate
redundancy. Avoid cliches like the plague. All generalizations are bad.
Corollary: All statements must be specific. Never listen to advice. Take
care that your verb and subject is in agreement. A preposition is a bad
thing to end a sentence with. Down with categorical imperatives. Avoid those
run-on sentences that just go on, and on, and on, they never stop, they just
keep rambling, and you really wish the person would just shut up, but no,
they just keep going, they're worse than the Energizer Bunny, they babble
incessantly, and these sentences, they just never stop, they go on
forever...if you get my drift... Never contradict yourself always. You
should never use the second person. When dangling, watch your participles.
Never go off on tangents, which are lines that intersect a curve at only one
point and were discovered by Euclid, who lived in the sixth century, which
was an era dominated by the Goths, who lived in what we now know as
Poland... As Ralph Waldo Emerson once said, 'I hate quotations.' Excessive
use of exclamation points can be disastrous!!!!! Remember to end each
sentence with a period Don't use commas, which aren't necessary. Don't use
question marks inappropriately? Don't be terse. Don't obfuscate your theses
with extraneous verbiage. Never use that totally cool, radically groovy
out-of-date slang. Avoid tumbling off the cliff of triteness into the black
abyss of overused metaphors. Keep your ear to the grindstone, your nose to
the ground, take the bull by the horns of a dilemma, and stop mixing your
metaphors. Avoid those abysmally horrible, outrageously repellent
exaggerations. Avoid any awful anachronistic aggravating antediluvian
alliterations.
~

95 BUILDER~
{138}
  Builder Help File

{128}  (A) {058}Mobile Programs
{128}  (B) {058}Object Programs
{128}  (C) {058}Bitvectors
{128}  (D) {058}Blueprints
{128}  (E) {058}OLC
{a}MPROGS000
{b}OPROGS000
{c}BITVECTORS00 BITVECTORS
{d}BLUEPRINTS0
{e}OLC
~

95 MPROGS000~
{138}
  Mobile Programs
{300}
{128}  (A) {058}Triggers           {128}  (D) {058}Operators
{128}  (B) {058}Variables          {128}  (E) {058}If Checks
{128}  (C) {058}Control Flow       {128}  (F) {058}Mob Commands

{128}  (-) {058}Return
{a}MPROGS100
{b}MPROGS200
{c}MPROGS300
{d}MPROGS400
{e}MPROGS500
{f}MPROGS700 MPCOMMANDS
{-}BUILDER
~

95 MPROGS100~
{138}
  Mobile Triggers
{300}
{128}  (A) {058}act_prog           {128}  (H) {058}all_greet_prog     {128}  (O) {058}range_prog
{128}  (B) {058}speech_prog        {128}  (I) {058}group_greet_prog   {128}  (P) {058}time_prog
{128}  (C) {058}social_prog        {128}  (J) {058}entry_prog         {128}  (Q) {058}repop_prog
{128}  (D) {058}rand_prog          {128}  (K) {058}give_prog          {128}  (R) {058}delay_prog
{128}  (E) {058}fight_prog         {128}  (L) {058}bribe_prog         {128}  (S) {058}exit_prog
{128}  (F) {058}hitprcnt_prog      {128}  (M) {058}death_prog         {128}  (T) {058}trigger_prog
{128}  (G) {058}greet_prog         {128}  (N) {058}kill_prog

{128}  (-) {058}Return
{a}MPROGS101
{b}MPROGS102
{c}MPROGS103
{d}MPROGS104
{e}MPROGS105
{f}MPROGS106
{g}MPROGS107
{h}MPROGS108
{i}MPROGS109
{j}MPROGS110
{k}MPROGS111
{l}MPROGS112
{m}MPROGS113
{n}MPROGS114
{o}MPROGS115
{p}MPROGS116
{q}MPROGS117
{r}MPROGS118
{s}MPROGS119
{t}MPROGS120
{-}MPROGS000
~

95 MPROGS101~
{138}
  Act Programs
{168}
>act_prog [p] <argument>
{300}
The argument is a list of keywords separated by spaces. If the first word is
the character 'p' by itself then the rest of the word list is considered to
be a phrase.  If the first word is the character 'k' by itself then the rest of
the word list is considered to be a set of keywords which all must be matched.
The trigger is activated whenever a keyword (or the phrase) is contained in the
act() message. Both the phrase and keywords are not case sensitive.

The act_prog will trigger on every action made by a player, it ignores mobs
~

95 MPROGS102~
{138}
  Speech Programs
{168}
>speech_prog [p] <argument>
{300}
The argument is a list of keywords separated by spaces. If the first word is
the character 'p' by itself then the rest of the word list is considered to
be a phrase.  If the first word is the character 'k' by itself then the rest of
the word list is considered to be a set of keywords which all must be matched.
The trigger is activated whenever a keyword (or the phrase) is contained in the
say message. Both the phrase and keywords are not case sensitive.

The speech_prog will trigger on every say made by a player, it ignores mobs
~

95 MPROGS103~
{138}
  Social Programs
{168}
>social_prog <argument>
{300}
The argument is a social listed in the social list.

The social_prog will trigger on every social made by a player or mob, where
the mobile with the program must be the target.
~

95 MPROGS104~
{138}
  Rand Programs
{168}
>rand_prog <percentage>
{300}
The argument is a number between 1 and 100

This trigger is checked every four seconds and if the argument is greater than
a percentage roll the trigger is activated. If there is no $r variable in the
program of the rand_prog this will happen even if there is no PC in the room
with the mob.

Mobs can have multiple rand_progs, but only 1 can trigger at a time.
~

95 MPROGS105~
{138}
  Fight Programs
{168}
>fight_prog <percentage>
{300}
The argument is a number between 1 and 100

This trigger is checked every combat round and if the argument is greater than
a percentage roll the trigger is activated. If there is no $r variable in the
program of the fight_prog this will happen even if there is no PC in the room
with the mob.

Mobs can have multiple fight_progs, but only 1 can trigger each combat round
~

95 MPROGS106~
{138}
  Hitprcnt Programs
{168}
>hitprcnt_prog <percentage>
{300}
The argument is a number between 1 and 100.

This trigger is checked every combat round and if the argument is greater than
a percentage roll the trigger is activated. If there is no $r variable in the
program of the hitprcnt_prog this will happen even if there is no PC in the
room with the mob.

Mobs can have multiple hitprcnt_progs, but only the 1th succesful one will
trigger each combat round. Multiple hitprcnt_progs should be listed in
increasing order of percent since a 40 will always be activated before a 20.

Be aware that a fight_prog and hitprcnt_prog can both trigger in 1 round.
~

95 MPROGS107~
{138}
  Greet Programs
{168}
>greet_prog <percentage>
{300}
The argument is a number between 1 and 100

This trigger is checked every time a PC enters the room with the mobile. The
mobile must be able to see the person walking in, otherwise the greet_prog
will not trigger.

The greet_prog will not trigger when the mobile is fighting
~

95 MPROGS108~
{138}
  All Greet Programs
{168}
>all_greet_prog <percentage>
{300}
The argument is a number between 1 and 100

This trigger is checked every time a PC enters the room with the mobile

The all_greet_prog will not trigger when the mobile is fighting
~

95 MPROGS109~
{138}
  Group Greet Programs
{168}
>group_greet_prog <percentage>
{300}
The argument is a number between 1 and 100

This trigger is checked every time a PC enters the room with the mobile and
if the argument is greater than a percentage roll the trigger is activated.

The mobile must be able to see the person walking in, otherwise the 
group_greet_prog will not trigger.

If a group enters all at once, the group_greet_prog is only triggered once

The group_greet_prog will not trigger when the mobile is fighting
~

95 MPROGS110~
{138}
  Entry Programs
{168}
>entry_prog <percentage>
{300}
The argument is a number between 1 and 100

This trigger is checked every time a mobile walks into a room and if the
argument is greater than a percentage roll the trigger is activated. If
there is no $r variable in the program of the entry_prog this will happen
even if there is no PC in the room with the mob.

Mobs can have multiple entry_progs, but only 1 can trigger each time
~

95 MPROGS111~
{138}
  Give Programs
{168}
>give_prog <argument>
{300}
The argument must be the name of an object

This trigger is checked every time a mobile is given an object. The argument
should always be used with the 'I' format for item vnums, except for a couple
of situations, but those go beyond the scope of this help file.

Example: A ball of light is vnum 21, so use: give_prog i25

$o will refer to the given object.
~

95 MPROGS112~
{138}
  Bribe Programs
{168}
>bribe_prog <argument>
{300}
The argument must be a number

This trigger is checked whenever money is given to the mobile. If the
amount given equals or exceeds the number, the program will be executed.

Only one bribe_prog can be triggered each time an amount of gold is given.

After the gold has been given it will be turned into a pile of gold in the
mobile's inventory.  A single coin has vnum 2, an amount of coins has vnum
3. They can be refered to as : I2 and I3.  Dropping the coins and picking
them up will turn them into cash.
~

95 MPROGS113~
{138}
  Death Programs
{168}
>death_prog <percentage>
{300}
The argument is a number between 1 and 100

This triggers when the mobile is about to die, before the corpse is made

The position of the mobile is temporary set to standing
~

95 MPROGS114~
{138}
  Kill Programs
{168}
>kill_prog <percentage>
{300}
The argument is a number between 1 and 100

This triggers when the mobile kills a player
~

95 MPROGS115~
{138}
  Range Programs
{168}
>range_prog <percentage>
{300}
The argument is a number between 1 and 100

This triggers when a mobile is hit by a range weapon

The shotfrom ifcheck can be used to see the direction the shot came from
~

95 MPROGS116~
{138}
  Time Programs
{168}
>time_prog <hour>
{300}
The argument is a number between 0 and 23

This is checked every mud hour, if the given hour matches the mud hour the
program will be executed.

If you use the number 24, the program will be triggered every mud hour.
~

95 MPROGS117~
{138}
  Repop Programs
{168}
>repop_prog <percentage>
{300}
The argument is a number between 1 and 100

This triggers when a mobile repops after dying and after a reboot
~

95 MPROGS118~
{138}
  Delay Programs
{168}
>delay_prog <index>
{300}
The index is a number between -100 and 100, if the index is below 0, the delay
program will be carried out even if the mobile is asleep.
{168}
Syntax: mpdelay <target> <seconds> <index> [argument]
{300}
-Seconds is the time in seconds of the delay, if the given time is equal or
 greater than 60, instead of being second based the delay will become mud
 hours based. (mud hours range from 30 to 90 seconds).
-The index is the index of the delay_prog that should be triggered when the
 delay expires.
-The argument can be any valid $* argument, or something of your own choice,
 or leave it blank if you don't want the mob to remember anything.
 You can read out this argument at anytime using $X.
{300}
-You can check if the target is already delayed using: if delayed ($*)
~

95 MPROGS119~
{138}
  Exit Programs
{168}
>exit_prog <direction>
{300}
The argument is either one of: n e s w u d

This trigger is checked every time a PC leaves the room with the mobile. The
mobile must be able to see the person walking out, otherwise the exit_prog
will not trigger.

The exit_prog will not trigger when the mobile is fighting.
~

95 MPROGS120~
{138}
  Trigger Programs
{168}
>trigger_prog [p k] <argument>
{300}
The argument is a list of keywords separated by spaces. If the first word is
the character 'p' by itself then the rest of the word list is considered to
be a phrase.  If the first word is the character 'k' by itself then the rest of
the word list is considered to be a set of keywords which all must be matched.
The trigger is activated whenever a keyword (or the phrase) is contained in the
mptrigger message. Both the phrase and keywords are not case sensitive.

The trigger_prog can only be triggered with the mptrigger <string> command.
~

95 MPROGS200~
{138}
  Variables (1)
{178}
  variable           mob     actor     vict     rand    objif   obj

  name                $i       $n       $t       $r      $c      $o
  short desc          $I       $N       $T       $R      $C      $O
  he/she/it           $j       $e       $E       $J      --      --
  him/her/it          $k       $m       $M       $K      --      --
  his/hers/its        $l       $s       $S       $L      --      --

{128}  (<) {058}Previous Page      {128}  (>) {058}Next Page          {128}  (-) {058}Return
{<}MPROGS201
{>}MPROGS201
{-}MPROGS000
~

95 MPROGS201~
{138}
  Variables (2)
{178}
  $D    name of door direction
  $d    number of door direction
  $x    number generated by if checks
  $X    string set to remember by mob
  $1    first word of trigger of speech/act program
  $9    ninth word of trigger of speech/act program
  $$    will print a single $

  self  a direct reference to the mob/players

{128}  (<) {058}Previous Page      {128}  (>) {058}Next Page          {128}  (-) {058}Return
{<}MPROGS200
{>}MPROGS200
{-}MPROGS000
~

95 MPROGS300~
{138}
  Control Flow
{300}
The following commands are available to control the flow in a mobile program:

if           checks for a condition  example: if level ($n) >= 10
or           checks for a condition  example: or level ($n) <= 50
and          checks for a condition  example: and level ($n) < 95

!            logical not:  example: if !delayed ($n)

else         is called when the result of the if check are false
elseif       is called when the result of the if check is false.
endif        ends an if check

break        bails out of the entire mobile program

switch       checks for a condition  example : switch level ($n)
case         checks for a specific value of the switch
default      checks if no case value has been found
endswitch    ends a switch

mpquiet on   all commands are executed unseen
mpquiet off  ends the quiet mode
~

95 MPROGS400~
{138}
  Operators
{300}
Numeric Operators:

 ==   equals
 !=   does not equal
  >   bigger than
  <   smaller than
 >=   bigger or equal than
 <=   smaller or equal than

String Operators: (not case sensative)

 ==   equals
 !=   does not equal
 /    contains
 !/   does not contain
~

95 MPROGS500~
{138}
  If Checks

{128}  (A) {058}General
{128}  (B) {058}Mobile
{128}  (C) {058}Player
{128}  (D) {058}Character
{128}  (E) {058}Object
{128}  (F) {058}Room

{128}  (-) {058}Return
{-}MPROGS000
{a}MPROGS510
{b}MPROGS540
{c}MPROGS570
{d}MPROGS600
{e}MPROGS630
{f}MPROGS660
~

95 MPROGS510~
{138}
  General If Checks

{128}  (A) {058} rand           {128}  (G) {058} existsworld
{128}  (B) {058} number         {128}  (H) {058} numberrange
{128}  (C) {058} name           {128}  (I) {058} areaquest
{128}  (D) {058} time
{128}  (E) {058} existsroom
{128}  (F) {058} existsarea

{128}  (-) {058} Return
{-}MPROGS500
{a}MPROGS511
{b}MPROGS512
{c}MPROGS513
{d}MPROGS514
{e}MPROGS515
{f}MPROGS516
{g}MPROGS517
{h}MPROGS518
{i}MPROGS519
~

95 MPROGS511~
{138}
  rand
{168}
Syntax: if rand (percentage)
{300}
The rand if check will generate a value between 1 and 100 and check if
the that value is smaller or equal to the given percentage.

$x will hold the generated percentage.
~

95 MPROGS512~
{138}
  number
{168}
Syntax: if number ($*) == integer
{300}
The number if check can be used for the $n $r $t $o $c $x and $X variable.

In the case of objects and mobiles it will compare the vnum of given variable.

$x will hold the compared value.
~

95 MPROGS513~
{138}
  name
{168}
Syntax: if name ($*) == string
{300}
The name if check can be used for the $n $r $t $o $c and $X variable.
~

95 MPROGS514~
{138}
  time
{168}
Syntax: if time () == hour
{300}
The time will compare the given hour to the current mud hour.

$x will hold the current mud hour.
~

95 MPROGS515~
{138}
  existsroom
{168}
Syntax: if existsroom ($* obj mob plr string)
{300}
The obj, mob, and plr argument will select a random obj, mob, or player in
the room.

The existsroom if check can be used for the $n $r and $X variable, it can
also be used by a self provided name of a mob, obj, or player you expect
to be in the room, or not to be.

$t will refer to the found character
$c will refer to the found object
~

95 MPROGS516~
{138}
  existsarea
{168}
Syntax: if existsarea ($* string)
{300}
The existsarea if check can be used for the $n $r and $X variable, it can
also be used by a self provided name of a mob, obj, or player you expect
to be in the area, or not to be.

$t will refer to the found character
$c will refer to the found object
~

95 MPROGS517~
{138}
  existsarea
{168}
Syntax: if existsworld ($* string)
{300}
The existsworld if check can be used for the $n $r and $X variable, it can
also be used by a self provided name of a mob, obj, or player you expect
to be in wherever in the mud world, or not to be.

$t will refer to the found character
$c will refer to the found object
~

95 MPROGS518~
{138}
  numberrange
{168}
Syntax: if numberrange(low,high) == integer
{300}
The numberrange if check can be used to generate a random number between the
given range.

$x will hold the generated random number.
~

95 MPROGS519~
{138}
  areaquest
{300}
Syntax: if areaquest (startBit, numBits, $*) == integer

Checks if the quest bits of area of $i $c or $o equals integer.

The quest checked will be of the area the mob or obj belongs to.

$x will hold the value of the checked bits
~

95 MPROGS540~
{138}
  Mobile If Checks

{128}  (A) {058} shotfrom
{128}  (B) {058} delayed

{128}  (-) {058} Return
{-}MPROGS500
{a}MPROGS541
{b}MPROGS542
~

95 MPROGS541~
{138}
  shotfrom
{168}
Syntax: if shotfrom ($i) == direction
{300}
The shotfrom ifcheck will compare given direction to the attacker's direction.

$D will hold the name of the direction the mob was attacked from.
~

95 MPROGS542~
{138}
  delayed
{168}
Syntax: if delayed ($*)
{300}
The delayed if check can be used for the $i $n $r and $t variable.

$x will hold the total delay in either seconds or mud hours for mobiles.
   if the target is a player it will hold their current lag timer.
~

95 MPROGS570~
{138}
  Player If Checks

{128}  (A) {058} iskiller       {128}  (G) {058} pcsinarea
{128}  (B) {058} isthief        {128}  (H) {058} pcsinroom
{128}  (C) {058} reinc          {128}  (I) {058} questr
{128}  (D) {058} age 
{128}  (E) {058} class     
{128}  (F) {058} whichgod

{128}  (-) {058} Return
{-}MPROGS500
{a}MPROGS571
{b}MPROGS572
{c}MPROGS573
{d}MPROGS574
{e}MPROGS575
{f}MPROGS576
{g}MPROGS577
{h}MPROGS578
{i}MPROGS579
~

95 MPROGS571~
{138}
  iskiller
{168}
Syntax: if iskiller ($*)
{300}
Checks if $n $r or $t is a killer.
~

95 MPROGS572~
{138}
  isthief
{168}
Syntax: if isthief ($*)
{300}
Checks if $n $r or $t is a thief.
~

95 MPROGS573~
{138}
  reinc
{168}
Syntax: if reinc ($*) == integer
{300}
This compares the reinc of $n $r or $t to given value.

$x will hold the compared value.
~

95 MPROGS574~
{138}
  age
{168}
Syntax: if age ($*) == integer
{300}
This compared the age of $n $r or $t to given value.

The age is calculated as following:  17 + (seconds played / 20000)

$x will hold the compared value.
~

95 MPROGS575~
{138}
  class
{168}
Syntax: if class ($*) == bitvector
{300}
This compares the class of $n $r or $t to given bitvector.

$x will hold the compared value.
~

95 MPROGS576~
{138}
  whichgod
{168}
Syntax: if whichgod ($*) == bitvector
{300}
This compares the god of $n $r or $t to given bitvector.

$x will hold the compared value.
~

95 MPROGS577~
{138}
  pcsinarea
{168}
Syntax: if pcsinarea (roomvnum) == integer
{300}
If the roomvnum is left blank it will use the current room the mob is in,
you can also use $x if it holds a room vnum.

This compares the amount of players in the area of given room to given
value.

$x will hold the compared value.
~

95 MPROGS578~
{138}
  pcsinroom
{168}
Syntax: if pcsinroom (roomvnum) == integer
{300}
If the roomvnum is left blank it will use the current room the mob is in,
you can also use $x if it holds a room vnum.

This compares the amount of players in the room of given room to given
value.

$x will hold the compared value.
~

95 MPROGS579~
{138}
  questr
{168}
Syntax: if questr (roomvnum, startBit, numBit, $*) == integer
{300}
This checks the questbits of $i $n $t $r for the area of the given roomvnum

{128}  (I) {058}More information on quest bits

{128}  (-) {058}Return
{-}MPROGS570
{i}QUESTBITS
~

95 MPROGS600~
{138}
  Character If Checks

{128}  (A) {058} isnpc          {128}  (G) {058} cancarry       {128}  (M) {058}race
{128}  (B) {058} ispc           {128}  (H) {058} isaffected     {128}  (N) {058}gold
{128}  (C) {058} isgood         {128}  (I) {058} hitprcnt       {128}  (O) {058}quest
{128}  (D) {058} isevil         {128}  (J) {058} sex            {128}  (P) {058}isfight
{128}  (E) {058} isneutral      {128}  (K) {058} postion        {128}  (Q) {058}isfollow
{128}  (F) {058} cansee         {128}  (L) {058} level

{128}  (-) {058} Return
{-}MPROGS000
{a}MPROGS601
{b}MPROGS602
{c}MPROGS603
{d}MPROGS604
{e}MPROGS605
{f}MPROGS606
{g}MPROGS607
{h}MPROGS608
{i}MPROGS609
{j}MPROGS610
{k}MPROGS611
{l}MPROGS612
{m}MPROGS613
{n}MPROGS614
{o}MPROGS615
{p}MPROGS616
{q}MPROGS617
~

95 MPROGS601~
{138}
  isnpc
{168}
Syntax: if isnpc ($*)
{300}
Checks if $n $r or $t is a player
~

95 MPROGS602~
{138}
  ispc
{168}
Syntax: if ispc ($*)
{300}
Checks if $n $r or $t is a mob
~

95 MPROGS603~
{138}
  isgood
{168}
Syntax: if isgood ($*)
{300}
Checks if $i $n $r or $t is of good alignment
~

95 MPROGS604~
{138}
  isevil
{168}
Syntax: if isevil ($*)
{300}
Checks if $i $n $r or $t is of good alignment
~

95 MPROGS605~
{138}
  isneutral
{168}
Syntax: if isneutral ($*)
{300}
Checks if $i $n $r or $t is of neutral alignment
~

95 MPROGS606~
{138}
  cansee
{168}
Syntax: if cansee ($*)
{300}
Checks if mobile can see $n $r or $t.
~

95 MPROGS607~
{138}
  cancarry
{168}
Syntax: if cancarry ($*)
{300}
Checks if $i $n $r or $t is capable of carrying any more items.
~

95 MPROGS608~
{138}
  isaffected
{168}
Syntax: if isaffected ($*) == spell name
{300}
Checks if $i $n $r or $t is affected by given spell
~

95 MPROGS609~
{138}
  hitprcnt
{168}
Syntax: if hitprcnt ($*) == percentage
{300}
Checks if health of $i $n $r or $t matches given hitpoints percentage.

$x will hold the target's hitpoints percentage.
~

95 MPROGS610~
{138}
  sex
{168}
Syntax: if sex ($*) == bitvector
{300}
Checks if sex of $i $n $r or $t matches given bitvector.

$x will hold the target's sex.
~

95 MPROGS611~
{138}
  position
{168}
Syntax: if position ($*) == bitvector
{300}
Checks if position of $i $n $r or $t matches given bitvector.

$x will hold the target's position.
~

95 MPROGS612~
{138}
  level
{168}
Syntax: if level ($*) == integer
{300}
Checks if the level of $i $n $r or $t equals integer.

$x will hold the target's level.
~

95 MPROGS613~
{138}
  race
{168}
Syntax: if race ($*) == bitvector
{300}
Checks if the race of $i $n $r or $t equals integer.

$x will hold the target's race.
~

95 MPROGS614~
{138}
  gold
{168}
Syntax: if gold ($*) == integer
{300}
Checks if the gold of $i $n $r or $t equals integer.

$x will hold the target's gold.
~

95 MPROGS615~
{138}
  quest
{168}
Syntax: if quest (startBit, numBits, $*) == integer

Checks if the quest bits of $i $n $r or $t equals integer.

The quest checked will be of the area the mob belongs to.

$x will hold the value of the checked bits.

{128}  (I) {058}More information on quest bits

{128}  (-) {058}Return
{-}MPROGS600
{i}QUESTBITS
~

95 MPROGS616~
{138}
  isfight
{168}
Syntax: if isfight ($*)
{300}
Checks if $i $n $r or $t is fighting someone.

$t will refer to the oponent the target is fighting
~

95 MPROGS617~
{138}
  isfollow
{168}
Syntax: if isfollow ($*)
{300}
Checks if $i $n $r or $t is following someone.

$t will refer to the character the target is following
~

95 MPROGS630~
{138}
  Object If Checks

{128}  (A) {058} objtype        {128}  (G) {058} hasobj
{128}  (B) {058} objval0        {128}  (H) {058} hasobjnum
{128}  (C) {058} objval1        {128}  (I) {058} wearsobjnum
{128}  (D) {058} objval2        {128}
{128}  (E) {058} objval3
{128}  (F) {058} objquest

{128}  (-) {058} Return
{-}MPROGS500
{a}MPROGS631
{b}MPROGS632
{c}MPROGS633
{d}MPROGS634
{e}MPROGS635
{f}MPROGS636
{g}MPROGS637
{h}MPROGS638
{i}MPROGS639
~

95 MPROGS631~
{138}
  objtype
{168}
Syntax: if objtype ($*) == bitvector
{300}
Checks if objtype of $c or $o equals given bitvector

$x will hold the object's object type
~

95 MPROGS632~
{138}
  objval0
{168}
Syntax: if objval0 ($i) == bitvector
{300}
Checks if objval0 of $c or $o equals given bitvector

$x will hold the object's value0
~

95 MPROGS633~
{138}
  objval1
{168}
Syntax: if objval1 ($i) == bitvector
{300}
Checks if objval1 of $c or $o equals given bitvector

$x will hold the object's value1
~

95 MPROGS634~
{138}
  objval2
{168}
Syntax: if objval2 ($i) == bitvector
{300}
Checks if objval2 of $c or $o equals given bitvector

$x will hold the object's value2
~

95 MPROGS635~
{138}
  objval3
{168}
Syntax: if objval3 ($i) == bitvector
{300}
Checks if objval3 of $c or $o equals given bitvector

$x will hold the object's value3
~

95 MPROGS636~
{138}
  objquest
{168}
Syntax: if objquest (startBit, numBits, $*) == integer
{300}
Checks if the quest bits of $c or $o equals given value.

$x will hold the value of the checked bits.

{128}  (I) {058}More information on quest bits

{128}  (-) {058}Return
{-}MPROGS630
{i}QUESTBITS
~

95 MPROGS637~
{138}
  hasobj
{168}
Syntax: if hasobj ($*) == name -- always use hasobjnum if possible
{300}
Checks if $* has an object with given name

$c will refer to the found object.
~

95 MPROGS638~
{138}
  hasobjnum
{168}
Syntax: if hasobjnum ($*) == objvnum
{300}
Checks if $* has an object with given vnum.

$c will refer to the found object.
~

95 MPROGS639~
{138}
  wearsobjnum
{168}
Syntax: if wearsobjnum ($*) == objvnum
{300}
Checks if $* has an object with the given vnum.

$c will refer to the found object.
~

95 MPROGS660~
{138}
  Room If Checks

{128}  (A) {058} validexit      {128}
{128}  (B) {058} findpath       {128}
{128}  (C) {058} inroom         {128}
{128}  (D) {058} roomsector     {128}
{128}  (E) {058} inarea         {128}

{128}  (-) {058} Return
{-}MPROGS500
{a}MPROGS661
{b}MPROGS662
{c}MPROGS663
{d}MPROGS664
{e}MPROGS665
~

95 MPROGS661~
{138}
  validexit
{168}
Syntax: if validexit (direction)
{300}
Checks if there is a valid exit in given direction the mobile is allowed
to use.

If no direction is given, the mob will select a random valid exit.

$D will hold the found direction.
$x will hold the room vnum the exit leads to.
~

95 MPROGS662~
{138}
  findpath
{168}
Syntax: if findpath (roomvnum, maxpathlength)
{300}
Checks if there is a path to given room vnum. The max pathlength is a value
between 1 and 100. It is suggested to keep the maxpathlength as low as
possible.

$D will hold the found direction leading 1 step closer toward the room.
$x will hold the length of the found path.
~

95 MPROGS663~
{138}
  inroom
{168}
Syntax: if inroom ($*) == roomvnum
{300}
Checks if the room vnum of $i $n $r or $t equals the given vnum.

$x will hold the vnum of the mob's current room vnum.
~

95 MPROGS664~
{138}
  roomsector
{168}
Syntax: if roomsector (vnum) == bitvector
{300}
Checks if the sector of given room vnum equals given bitvector.

$x will hold the value of the room's sector.
~

95 MPROGS665~
{138}
  inarea
{168}
Syntax: if inarea ($*) == areavnum
{300}
Checks if the area vnum of $i $n $r or $t equals the given vnum.

The area vnum is the vnum of the lowest room vnum in the area.

$x will hold the vnum of the mob's current area vnum.
~

95 QUESTBITS~
{138}
  Quest Bits for Dummies
{300}
Every Player has 128 bits allocated for every area, at default those bits
are all set to zero.

The mprog code will allow you to select up to 32 bits at a time from the
total of 128. It is highly suggested (so just do it) that you always select
groups of 4 bits. This being 4, 8, 12, etc bits.

To select a group of bits:

-first select the first bit of the group of bits you want to use, this is
 a number between 0 and 124. The number must dividable by 4, thus
 being 0, 4, 8, 12, 16, etc.
-second select the amount of bits, this is a number between 4 and 32,
 being 4, 8, 12, 16, etc.

Depending on the amount of bits you select you can assign a certain value to
those bits. Here is an overview for the most commonly used amounts of bits:

 4 bits allows you to set a value between 0 and   15
 8 bits allows you to set a value between 0 and  255
12 bits allows you to set a value between 0 and 4095

example:

if quest (0,4,$n) == 6  Checks if bits 0, 1, 2, 3, equal 6
if quest (4,4,$n) == 0  Checks if bits 4, 5, 6, 7, equal 0

Setting a quest bit goes very much the same way.

Example

mpmset $n quest 0 4 9  Sets bits 0, 1, 2, 3, to equal 9
mpmset $n quest 8 8 69 Sets bits 8, 9, 10, 11, 12, 13, 14, 15, to equal 69

Notes:

-mpmadd $n quest 0 4 1  will increase the value of the quest bits, once the
 value becomes 15, and you try to increase the value, the value will become
 0. You can use that behavior to your advantage.

-Quest bits can be set on players, mobs and objects.
~

95 MPROGS700 MPCOMMANDS~
{138}
  Mob Commands
{300}
{128}  (A) {058}mpmset      {128}  (H) {058}mppurge      {128}  (O) {058}mptransfer    {128}  (V) {058}mpmaze
{128}  (B) {058}mpmadd      {128}  (I) {058}loading      {128}  (P) {058}mpat          {128}  (W) {058}rescale
{128}  (C) {058}mposet      {128}  (J) {058}mpswap       {128}  (Q) {058}peace         {128}  (X) {058}echos
{128}  (D) {058}mpoadd      {128}  (K) {058}mpkill       {128}  (R) {058}slay          {128}  (Y) {058}mpdelay
{128}  (E) {058}mpaset      {128}  (L) {058}mpforce      {128}  (S) {058}connect       {128}  (Z) {058}mptrigger
{128}  (F) {058}mpzset      {128}  (M) {058}mpgoto       {128}  (T) {058}doorset       {128}  (1) {058}mpseed
{128}  (G) {058}mpjunk      {128}  (N) {058}mpgorand     {128}  (U) {058}mpdamage

{128}  (-) {058}Return
{a}MPMSET
{b}MPMADD
{c}MPOSET
{d}MPOADD
{e}MPASET
{f}MPZSET
{g}MPJUNK MPJUNKPERSON
{h}MPPURGE
{i}MPOLOAD MPMLOAD
{j}MPSWAP
{k}MPKILL
{l}MPFORCE
{p}MPAT
{r}SLAY
{s}CONNECT
{t}DOORSET
{u}MPDAMAGE
{v}MPMAZE
{w}RESCALE
{x}ECHO MPAREAECHO MPASOUND MPECHO MPECHOAT MPECHOAROUND
{y}MPDELAY
{z}MPTRIGGER
{1}MPSEED
{-}MPROGS000
~

95 MPMSET~
{168}
Syntax: mpmset <victim> <field>  <argument>
Syntax: mpmset <victim> <string> <argument>

{300}Field being one of:
{078}  level gold align thirst drunk full exp wait dam hp mana move
{300}String being one of:
{078}  remember name short long title

{168}Syntax: mpmset <victim> quest                 <firstBit> <numBits> <newValue>
{168}Syntax: mpmset <victim> questr     <areaVnum> <firstBit> <numBits> <newValue>
{168}Syntax: mpmset <victim> randquest             <firstBit> <numBits>
{168}Syntax: mpmset <victim> randquestr <areaVnum> <firstBit> <numBits>
~

95 MPMADD~
{168}
Syntax: mpmadd <victim> <field> <argument>

{300}Field being one of:
{078}  level gold align thirst drunk full exp currhp currmana currmove hp mana move
{078}  quest questr

{168}Syntax: mpmadd <victim> quest             <firstBit> <numBits> <value>
{168}Syntax: mpmadd <victim> questr <areaVnum> <firstBit> <numBits> <value>
~

95 MPOSET~
{168}
Syntax: mposet <object> <field>  <argument>
Syntax: mposet <object> <string> <argument>

{300}Field being one of:
{078}  value0 value1 value2 value3 extra setextra clrextra wear level weight cost
{078}  timer quest randquest
{300}String being one of:
{078}  name short long ed

{168}Syntax: mposet <object> quest     <firstBit> <numBits> <newValue>
{168}Syntax: mposet <object> randquest <firstBit> <numBits>
~

95 MPOADD~
{168}
Syntax: mpoadd <object> <field> <argument>

{300}Field being one of:
{078}  value0 value1 value2 value3 level weight cost timer quest

{168}Syntax: mpoadd <object> quest <firstBit> <numBits> <value>
~

95 MPASET~
{168}
Syntax: mpaset <object> <field> <argument>

{300}Field being one of:
{078}  str dex int wis con mana hp move ac damroll hitroll
{078}  para rod petri breath spell
~

95 MPZSET~
{168}
Syntax: mpzset <field> <argument>

{300}Field being one of:
{078}  resetmsg quest
~

95 MPJUNK MPJUNKPERSON~
{168}
Syntax: mpjunk                <object|all>
Syntax: mpjunkperson <target> <object|all>
{300}
The object must be worn or carried in inventory to be junked
~

95 MPPURGE~
{168}
Syntax: mppurge [object|mobile|all|area]
{300}
The object or mobile must be located in the room
If the all argument is given every object and mobile in the room will be purged
mppurge area, will purge the entire area except for the mob that purges the
area.
~

95 MPOLOAD MPMLOAD~
{168}
Syntax: mpoload <vnum> [room] [wear]
Syntax: mpmload <vnum>
{300}
mpoload will place an object in the inventory of the mobile, if the object
doesn't have the item_wear_take flag or you use the room argument it will
go to the room. The wear argument will equip the mob with loaded object.

mpmload will load a mobile in the room
~

95 MPSWAP~
{168}
Syntax: mpswap <dir1> <dir2>
{300}
mpswap will swap the given directions. This can be used to create mazes
with less limitations than the randomization reset.
~

95 MPKILL~
{168}
Syntax: mpkill <target>
{300}
mpkill allows a mobile to attack other mobiles and players
~

95 MPDO~
{168}
Syntax: mpdo <argument>
{300}
This will allow the mobile to execute non existing commands. Which in most
cases will be a command stored into a mprog variable such as 'mpdo $C'.
~

95 MPDELAY~
{168}
Syntax: mpdelay <target> <time> <index> [remember]
{300}
After given 'time' the target's delay_prog with given 'index' will trigger.
Setting a string to be remembered is optional.
A mobile can only have 1 delay program pending, so use the if delayed($*)
check to avoid erasing an already pending delay trigger.
~

95 MPTRIGGER~
{168}
Syntax: mptrigger <target> <string>
{300}
This will send the given string to the target mob much like mpechoat, if the
target mob has a trigger_prog set that matches the string it will execute that
prog and is able to process the keywords passed along as well. This is useful
for object programs to trigger mobile programs, or mobs triggering other mobs
or themself.
~

95 MPSEED~
{168}
Syntax: mpseed <number|player>
{300}
This will seed the random number generator. If the same seed is used, a
sequence of random number calculation will always be the same. If a player
is given the seed will be based on the player's vnum. 
~

95 MPCALCULATE~
{168}
Syntax: mpcalculate <value> <operator> <value>
{300}
Operators       Priority     Function
------------------------------------------------
*               1            integer multiply
{300}/               1            integer divide
%               1            integer modulo
d               1            integer random dice roll
+               2            integer addition
-               2            integer subtraction
>               4            logical greater than
>=              4            logical greater than or equal
<               4            logical less than
<=              4            logical less than or equal
==              5            logical equal (can use wildcards)
{300}!=              5            logical not equal (can use wildcards)
&&              9            logical and
^^             10            logical xor
||             11            logical or
~

95 MPFORCE~
{168}
Syntax: mpforce <target|all|allgame> <argument>
{300}
mpforce <target> will force the target to do something
mpforce all      will force all mobiles and players in the room
mpforce allgame  will force all players in the game
~

95 MPGOTO~
{168}
Syntax: mpgoto <roomVnum|mobile|object>
{300}
mpgoto roomVnum will take the mobile to the specified room
mpgoto mobile   will take the mobile to the specified mobile name
mpgoto object   will take the mobile to the specified object name
~

95 MPGORAND~
{168}
Syntax: mpgorand <firstRoom> <lastRoom> <offset> <skipSize>
{300}
mpgorand will take the mobile to a random room in the specified vnum range
~

95 MPTRANSFER~
{168}
Syntax: mptransfer <target|all|pcs> <roomVnum>
{300}
mptransfer target will transfer target to specified room
mptransfer all    will transfer all mobs and players to specified room
mptransfer pcs    will transfer all mobs to specified room
~

95 MPAT~
{168}
Syntax: mpat <roomVnum|mobile|object> <command>
{300}
mpat roomVnum will execute a command at the specified room
mpat mobile   will execute a command at the specified mobile name
mpat object   will execute a command at the specified object name
~

95 PEACE~
{168}
Syntax: peace
{300}
peace will stop all fighting and strip all hating/hunting flags from
all mobiles standing in the room
~

95 SLAY~
{168}
Syntax: slay <target>
{300}
slay will kill the target instantly without adding a death
~

95 CONNECT~
{168}
Syntax: connect <direction> <roomVnum> [both]
{300}
connect will connect the specified room in the specified direction
If the 'both' argument is used a 2 way connection will be established
~

95 DOORSET~
{168}
Syntax: doorset <direction> <field> <argument>

{300}Field being one of:
{078}  desc name flag key
{300}
This command will only set one side of the door.
~

95 MPDAMAGE~
{168}
Syntax: mpdamage <victim|all|pcs|foe> <dam_lo> <dam_hi> <nounce>
{300}
mpdamage can be used to have a mobile do specialized damage, if the damage
dealt equals zero the attack will miss.

all - will hit all targets mobile can attack
pcs - will hit all players mobile can attack
foe - will hit the person the mobile is currently fighting
~

95 MPMAZE~
{168}
Syntax: mpmaze <x size> <y size> <z size> <total rooms>
{300}
This command will restructure the total rooms, starting count from the room
the mobile stands in, into an x*y*z block. There must be enough available
rooms with none of them missing. The maze will entirely exist of 2 way
connections, so you will likely have to spice it up a little after the maze
command has been executed, or maze up small amounts of rooms.

Example: maze 4 4 4 30 will fit 30 rooms in a 4 by 4 by 4 area.
~

95 RESCALE~
{168}
Syntax: rescale <mobVnum> <target> <percentage>
{300}
The level, damage, and hitpoints of the mobile will be rescaled

Formula: newLevel = mobLevel * targetLevel/100 * percentage/100
~

95 ECHO MPAREAECHO MPASOUND MPECHO MPECHOAT MPECHOAROUND~
{168}
Syntax: echo                  <string> echo to all players
Syntax: mpareaecho            <string> echo to players in area
Syntax: mpasound              <string> echo to surrounding rooms
Syntax: mpecho                <string> echo to room
Syntax: mpechoat     <target> <string> echo to target
Syntax: mpechoaround <target> <string> echo to room excluding target
{300}
All echos can be executed containing color codes

Except for echo the targets must be awake to see the message, mpareaecho
has some advanced options:
mpareaecho <sleepers indoors outdoors> <string>
~

95 OPROGS000~
{138}
  Mobile Programs
{300}
{128}  (A) {058}Triggers

{128}  (-) {058}Return
{a}OPROGS100
{-}BUILDER
~

95 OPROGS100~
{138}
  Object Triggers
{300}
{128}  (A) {058}command_prog       {128}  (H) {058}sacrifice_prog     {128}  (O) {058}          
{128}  (B) {058}damage_prog        {128}  (I) {058}unknown_prog       {128}  (P) {058}           
{128}  (C) {058}drop_prog          {128}  (J) {058}wear_prog          {128}  (Q) {058}          
{128}  (D) {058}get_prog           {128}  (K) {058}                   {128}  (R) {058}           
{128}  (E) {058}hit_prog           {128}  (L) {058}                   {128}  (S) {058}         
{128}  (F) {058}rand_prog          {128}  (M) {058}                   {128}  (T) {058}            
{128}  (G) {058}remove_prog        {128}  (N) {058}         

{128}  (-) {058}Return
{a}OPROGS101
{b}OPROGS102
{c}OPROGS103
{d}OPROGS104
{e}OPROGS105
{f}OPROGS106
{g}OPROGS107
{h}OPROGS108
{i}OPROGS109
{j}OPROGS110
{k}OPROGS111
{-}OPROGS000
~

95 OPROGS101~
{138}
  Trigger Command
{168}
TRIG_COMMAND <PERCENTAGE> <COMMAND>
{300}
The percentage must be a number between 1 and 100

The command must be listed in interp.c (skills/commands/godcommands)
~

95 OPROGS102~
{138}
  Trigger Unknown
{168}
TRIG_UNKNOWN <PERCENTAGE> <STRING>
{300}
The percentage must be a number between 1 and 100

The string shouldn't be listed in interp.c (skills/commands/godcommands)
~

95 OPROGS103~
{138}
  Trigger Tick
{168}
TRIG_TICK <PERCENTAGE>
{300}
The percentage must be a number between 1 and 100

Every 4 seconds the percentage will be checked
~

95 OPROGS104~
{138}
  Trigger Hit
{168}
TRIG_HIT <PERCENTAGE>
{300}
The percentage must be a number between 1 and 100

Everytime the player is hit (non magical) the percentage will be checked
~

95 OPROGS105~
{138}
  Trigger Damage
{168}
TRIG_DAMAGE <PERCENTAGE>
{300}
The percentage must be a number between 1 and 100

Everytime the player does damage (non magical) the percentage will be checked
~

95 OPROGS106~
{138}
  Rand Programs
{168}
>rand_prog <percentage>
{300}
The argument is a number between 1 and 100

This trigger is checked every 4 seconds and if the argument is greater than a
percentage roll the trigger is activated. The object must be carried by a
player in order to have its rand prog trigger.

Objects can have multiple rand_progs, but only 1 can trigger at a time.
~

95 OPROGS107~
{138}
  Trigger Remove
{168}
TRIG_REMOVE <PERCENTAGE>
{300}
The percentage must be a number between 1 and 100

Everytime the player removes the object the percentage will be checked
~

95 OPROGS108~
{138}
  Trigger Void
{168}
TRIG_VOID
{300}
This indicates the trigger is called by another section of the object program
~

95 OPROGS109~
{138}
  Trigger Sacrifice
{168}
TRIG_SACRIFICE <PERCENTAGE>
{300}
This triggers when the object is being sacrificed by the player.
~

95 OPROGS110~
{138}
  Trigger Roomcommand
{168}
TRIG_ROOM_COMMAND <PERCENTAGE> <COMMAND>
{300}
This triggers when the command is used in the room with the object.
The command must be a real command, socials don't count.
The object Must be lying on the ground.
~

95 OPROGS111~
{138}
  Trigger Unknowncommand
{168}
TRIG_ROOM_UNKNOWN <PERCENTAGE> <COMMAND>
{300}
This triggers when the command is used in the room with the object.
The object Must be lying on the ground.
The command should not be a real command, but can be a social.
~

95 BITVECTORS00 BITVECTORS~
{138}
  Bitvectors

{128}  (A) {058}Areas              {128}  (D) {058}Rooms
{128}  (B) {058}Mobiles/Players    {128}  (E) {058}Resets
{128}  (C) {058}Objects            {128}  (F) {058}Players

{128}  (-) {058}Return
{a}BITVECTORS10
{b}BITVECTORS20
{c}BITVECTORS300
{d}BITVECTORS40
{e}BITVECTORS50
{f}BITVECTORS60
{-}BUILDER
~

95 BITVECTORS10~
{138}
  Area Flags
{078}
  AFLAG_NODEBUG            AFLAG_NORECALL
  AFLAG_NOTELEPORT         AFLAG_NOCASTLE
  AFLAG_NOGOHOME           AFLAG_NORIP
~

95 BITVECTORS20~
{138}
  Mobile Bitvectors
{078}
{128}  (A) {058}Mobile Actions
{128}  (B) {058}Mobile Affects
{128}  (C) {058}Body Parts
{128}  (D) {058}Mobile Races
{128}  (E) {058}Mobile Positions
{128}  (F) {058}Mobile Genders
{128}  (G) {058}Player Gods
{128}  (H) {058}Player Classes

{128}  (-) {058}Return
{a}BITVECTORS21
{b}BITVECTORS22
{c}BITVECTORS23
{d}BITVECTORS24
{e}BITVECTORS25
{f}BITVECTORS26
{a}BITVECTORS27
{b}BITVECTORS28
{-}BITVECTORS00 BITVECTORS
~

95 BITVECTORS21~
{138}
  Mobile Actions
{078}
  ACT_SENTINEL             ACT_TRAIN                ACT_NO_ORDER
  ACT_SCAVENGER            ACT_PRACTICE             ACT_BODY
  ACT_DRUNK                ACT_WEAK                 ACT_RACE
  ACT_AGGRESSIVE           ACT_SMART                ACT_UNDEAD
  ACT_WIMPY                ACT_ONE_FIGHT
~

95 BITVECTORS22~
{138}
  Mobile Affects
{078}
  AFF_DETECT_HIDDEN        AFF_ETHEREAL             AFF_UNDERSTAND
  AFF_DETECT_INVIS         AFF_INVISIBLE            AFF_TONGUES
  AFF_PROTECT_EVIL         AFF_STEALTH              AFF_SLEEP
  AFF_PROTECT_GOOD         AFF_SNEAK                AFF_CHARM
  AFF_PASS_DOOR            AFF_HIDE                 AFF_TRUESIGHT
  AFF_FLYING               AFF_HUNT                 AFF_POISON
  AFF_SANCTUARY            AFF_CLEAR                AFF_STABILITY
 ~

95 BITVECTORS23~
{138}
  Body Parts
{078}
  BODY_HEAD           BODY_LEG                      BODY_HORN
  BODY_MOUTH          BODY_ARM                      BODY_CLAW
  BODY_EYE            BODY_WING                     BODY_HAND
  BODY_TORSO          BODY_TAIL                     BODY_FOOT
  BODY_HIP            BODY_TENTICLE
~

95 BITVECTORS24~
{138}
  Mobile Races
{078}
  RACE_HUMAN          RACE_ELF           RACE_DROW           RACE_DWARF
  RACE_GNOME          RACE_ORC           RACE_HOBBIT         RACE_OGRE                RACE_TROLL
~

95 BITVECTORS25~
{138}
  Mobile Positions
{078}
  POS_DEAD                   POS_STUNNED              POS_FIGHTING
  POS_MORTAL                 POS_SLEEPING             POS_STANDING
  POS_INCAP                  POS_RESTING
~

95 BITVECTORS26~
{138}
  Mobile Genders
{078}
  SEX_NEUTRAL                SEX_MALE                 SEX_FEMALE
~

95 BITVECTORS27~
{138}
  God Flags
{078}
  GOD_NEUTRAL              GOD_CHAOS                GOD_ORDER
~

95 BITVECTORS28~
{138}
  Class Flags
{078}
  CLASS_RANGER             CLASS_NINJA              CLASS_NECROMANCER
  CLASS_GLADIATOR          CLASS_ELEMENTALIST
  CLASS_MARAUDER           CLASS_ILLUSIONIST
~

95 BITVECTORS300~
{138}
  Object Bitvectors

{128}  (A) {058}Object Types
{128}  (B) {058}Object Flags
{128}  (C) {058}Wear Locations
{128}  (D) {058}Object Applies
{128}  (E) {058}Object Classes
{128}  (F) {058}Value0
{128}  (G) {058}Value1
{128}  (H) {058}Value2
{128}  (I) {058}Value3

{128}  (-) {058}Return
{a}BITVECTORS310
{b}BITVECTORS320
{c}BITVECTORS330
{d}BITVECTORS340
{e}BITVECTORS350
{f}BITVECTORS360
{g}BITVECTORS370
{h}BITVECTORS380
{i}BITVECTORS390
{-}BITVECTORS00 BITVECTORS
~

95 BITVECTORS310~
{138}
  Object Types
{078}
  ITEM_TYPE_NOTHING        ITEM_TYPE_ARMOR            ITEM_TYPE_FOOD
  ITEM_TYPE_LIGHT          ITEM_TYPE_POTION           ITEM_TYPE_MONEY
  ITEM_TYPE_SCROLL         ITEM_TYPE_FURNITURE        ITEM_TYPE_BOAT
  ITEM_TYPE_WAND           ITEM_TYPE_TRASH            ITEM_TYPE_FOUNTAIN
  ITEM_TYPE_STAFF          ITEM_TYPE_CONTAINER        ITEM_TYPE_PILL
  ITEM_TYPE_WEAPON         ITEM_TYPE_DRINK_CON        ITEM_TYPE_AMMO
  ITEM_TYPE_TREASURE       ITEM_TYPE_KEY
~

95 BITVECTORS320~
{138}
  Object Flags
{078}
  ITEM_FLAG_HUM            ITEM_FLAG_BLESS          ITEM_FLAG_INVENTORY
  ITEM_FLAG_EVIL           ITEM_FLAG_ANTI_NEUTRAL   ITEM_FLAG_LEVEL
  ITEM_FLAG_INVIS          ITEM_FLAG_ANTI_GOOD      ITEM_FLAG_AUTO_ENGRAVE
  ITEM_FLAG_MAGIC          ITEM_FLAG_ANTI_EVIL      ITEM_FLAG_GLOW
  ITEM_FLAG_NODROP         ITEM_FLAG_NOREMOVE
~

95 BITVECTORS330~
{138}
  Wear Locations
{078}
  ITEM_WEAR_TAKE           ITEM_WEAR_LEGS           ITEM_WEAR_ABOUT
  ITEM_WEAR_FINGER         ITEM_WEAR_FEET           ITEM_WEAR_WAIST
  ITEM_WEAR_NECK           ITEM_WEAR_HANDS          ITEM_WEAR_WRIST
  ITEM_WEAR_BODY           ITEM_WEAR_ARMS           ITEM_WEAR_WIELD
  ITEM_WEAR_HEAD           ITEM_WEAR_SHIELD         ITEM_WEAR_HOLD
~

95 BITVECTORS340~
{138}
  Object Applies
{078}
  APPLY_STR                APPLY_MANA               APPLY_SAVING_PARA
  APPLY_DEX                APPLY_HIT                APPLY_SAVING_ROD
  APPLY_INT                APPLY_MOVE               APPLY_SAVING_PETRI
  APPLY_WIS                APPLY_AC                 APPLY_SAVING_BREATH
  APPLY_CON                APPLY_HITROLL            APPLY_SAVING_SPELL
  APPLY_SEX                APPLY_DAMROLL
~

95 BITVECTORS350~
{138}
  Object Classes
{078}
  FLAG_CLASS_RANGER        FLAG_CLASS_NINJA         FLAG_CLASS_MONK  
  FLAG_CLASS_GLADIATOR     FLAG_CLASS_ELEMENTALIST  FLAG_CLASS_NECROMANCER
  FLAG_CLASS_MARAUDER      FLAG_CLASS_ILLUSIONIST
~

95 BITVECTORS360~
{138}
  Value0
{078}
  No bitvectors available yet
~

95 BITVECTORS370~
{138}
  Value1
{078}
{128}  (A) {058}Pills Potions Scrolls
{128}  (B) {058}Containers

{128}  (-) {058}Return
{a}SPELLS0
{b}BITVECTORS371
{-}BITVECTORS300
~

95 BITVECTORS371~
{138}
  Containers
{078}
  CONT_CLOSEABLE
  CONT_PICKPROOF
  CONT_CLOSED
  CONT_LOCKED
~

95 BITVECTORS380~
{138}
  Value2
{078}
{128}  (A) {058}Pills Potions Scrolls
{128}  (B) {058}Drink Containers

{128}  (-) {058}Return
{a}SPELLS0
{b}BITVECTORS381
{-}BITVECTORS300
~

95 BITVECTORS381~
{138}
  Drink Containers
{078}
  LIQ_WATER                LIQ_LEMONADE             LIQ_COFFE
  LIQ_BEER                 LIQ_FIREBRT              LIQ_BLOOD
  LIQ_WINE                 LIQ_LOCALSPC             LIQ_SALTWATER
  LIQ_ALE                  LIQ_SLIME                LIQ_COKE
  LIQ_DARKALE              LIQ_MILK
  LIQ_WHISKY               LIQ_TEA
~

95 BITVECTORS390~
{138}
  Value3
{078}
{128}  (A) {058}Pills Potions Scrolls
{128}  (B) {058}Staves Wands
{128}  (C) {058}Weapons

{128}  (-) {058}Return
{a}SPELLS0
{b}SPELLS0
{c}BITVECTORS391
{-}BITVECTORS300
~

95 BITVECTORS391~
{138}
  Weapons
{078}
  WEAPON_SLICE             WEAPON_CLAW              WEAPON_GREP
  WEAPON_STAB              WEAPON_BLAST             WEAPON_BITE
  WEAPON_SLASH             WEAPON_POUND             WEAPON_PIERCE
  WEAPON_WHIP              WEAPON_CRUSH
~

95 BITVECTORS40~
{138}
  Room Bitvectors

{128}  (A) {058}Room Flags
{128}  (B) {058}Room Sectors
{128}  (C) {058}Exit Directions
{128}  (D) {058}Door Flags

{128}  (-) {058}Return
{a}BITVECTORS41
{b}BITVECTORS42
{c}BITVECTORS43
{d}BITVECTORS44
{-}BITVECTORS00 BITVECTORS
~

95 BITVECTORS41~
{138}
  Room Flags
{078}
  ROOM_DARK                ROOM_PRIVATE             ROOM_NO_MOB
  ROOM_SMOKE               ROOM_SOLITARY            ROOM_NO_GOHOME
  ROOM_INDOORS             ROOM_ALLOW_WAR           ROOM_NO_RECALL
  ROOM_SAFE                ROOM_ALLOW_GLA           ROOM_NO_SAVE
  ROOM_BANK                ROOM_ALLOW_MAR           ROOM_NO_CASTLE
  ROOM_PET_SHOP            ROOM_ALLOW_NIN           ROOM_NO_RIP
  ROOM_MORGUE              ROOM_ALLOW_DRU
  ROOM_ALTAR_N             ROOM_ALLOW_SOR
  ROOM_NOTE_BOARD          ROOM_ALLOW_SHA
  ROOM_BLOCK               ROOM_ALLOW_WLC
~

95 BITVECTORS42~
{138}
  Room Sectors
{078}
  SECT_INSIDE              SECT_WATER_NOSWIM        SECT_ASTRAL
  SECT_CITY                SECT_UNUSED              SECT_UNDER_WATER
  SECT_FIELD               SECT_AIR                 SECT_UNDER_GROUND
  SECT_FOREST              SECT_DESERT              SECT_DEEP_EARTH
  SECT_HILLS               SECT_LAVA
  SECT_MOUNTAIN            SECT_INN
  SECT_WATER_SWIM          SECT_ETHEREAL
~

95 BITVECTORS43~
{138}
  Exit Directions
{078}
  DIR_NORTH                DIR_EAST                 DIR_SOUTH
  DIR_WEST                 DIR_UP                   DIR_DOWN
~

95 BITVECTORS44~
{138}
  Door Flags
{078}
  EX_ISDOOR                EX_HIDDEN                EX_MAGICPROOF
  EX_CLOSED                EX_PICKPROOF             EX_PASSPROOF
  EX_LOCKED                EX_BASHPROOF             EX_MAGICAL_LOCK
  EX_TRAPPED_LOCK          EX_MECHANICAL_LOCK       EX_SMALL_LOCK
  EX_BIG_LOCK              EX_EASY_PICK             EX_HARD_PICK
~

95 BITVECTORS50~
{138}
  Reset Bitvectors

{128}  (A) {058}Exit Directions
{128}  (B) {058}Reset Door Flags
{128}  (C) {058}Reset Wear Locations

{128}  (-) {058}Return
{a}BITVECTORS51
{b}BITVECTORS52
{c}BITVECTORS53
{-}BITVECTORS00 BITVECTORS
~

95 BITVECTORS51~
{138}
  Exit Directions
{078}
  DIR_NORTH                DIR_EAST                 DIR_SOUTH
  DIR_WEST                 DIR_UP                   DIR_DOWN
~

95 BITVECTORS52~
{138}
  Door Reset Flags
{078}
  DOOR_OPEN
  DOOR_CLOSED
  DOOR_CLOSED_LOCKED
~

95 BITVECTORS53~
{138}
  Reset Wear Locations
{078}
  WEAR_NONE                WEAR_HEAD                WEAR_WAIST
  WEAR_LIGHT               WEAR_LEGS                WEAR_WRIST_L
  WEAR_FINGER_L            WEAR_FEET                WEAR_WRIST_R
  WEAR_FINGER_R            WEAR_HANDS               WEAR_WIELD
  WEAR_NECK_A              WEAR_ARMS                WEAR_HOLD
  WEAR_NECK_B              WEAR_SHIELD
  WEAR_BODY                WEAR_ABOUT
~

95 BITVECTORS60~
{138}
  Player Bitvectors

{128}  (A) {058}Gods
{128}  (B) {058}Classes

{128}  (-) {058}Return
{a}BITVECTORS61
{b}BITVECTORS62
{-}BITVECTORS00 BITVECTORS
~

95 BITVECTORS61~
{138}
  Player God Flags
{078}
  GOD_NEUTRAL              GOD_MANWE                GOD_ULMO
  GOD_DEMISE               GOD_HYPNOS               GOD_GAIA
~

95 BITVECTORS62~
{138}
  Player Class Flags
{078}
  CLASS_RANGER             CLASS_NINJA              CLASS_MONK  
  CLASS_GLADIATOR          CLASS_ELEMENTALIST       CLASS_NECROMANCER
  CLASS_MARAUDER           CLASS_ILLUSIONIST 
~

95 SPELLS0~
{138}
  Spells are referenced to by their name.
~

95 BLUEPRINTS0~
{138}
  Blueprints

{128}  (A) {058}#AREA
{128}  (B) {058}#HELPS
{128}  (C) {058}#MOBILES
{128}  (D) {058}#OBJECTS
{128}  (E) {058}#ROOMS
{128}  (F) {058}#SHOPS
{128}  (G) {058}#RESETS

{128}  (-) {058}Return
{a}BLUEPRINTS1
{b}BLUEPRINTS2
{c}BLUEPRINTS3
{d}BLUEPRINTS4
{e}BLUEPRINTS5
{f}BLUEPRINTS6
{g}BLUEPRINTS7
{-}BUILDER
~

95 BLUEPRINTS1~
{300}
{078}#AREA        {300}<{078}area name{300}>{078}
{078}#AUTHORS     {300}<{078}creator{300}>{078}
{078}#RESETMSG    {300}<{078}string{300}>{078}
{078}#RANGES      {300}<{078}low_soft{300}> <{078}hi_soft{300}> <{078}low_hard{300}> <{078}hi_hard{300}>
{078}#TEMPERATURE {300}<{078}winter low{300}> <{078}summer low{300}> <{078}daily change{300}> <{078}wetness{300}>
{078}#FLAGS       {300}<{078}area flags{300}>
~

95 BLUEPRINTS2~
{300}
{078}#HELPS
{300}
{300}<{078}level of help{300}> <{078}keywords{300}>{078}
{078}
{300}<{078}help text{300}>
{300}
{300}<{078}link{300}>{078} {300}<{078}keyword{300}>
{078}
{078}
{078}0 $
~

95 BLUEPRINTS3~
{300}
{078}#MOBILES
{300}
{300}<{078}#vnum{300}>
{300}<{078}name list{300}>{078}
{300}<{078}short description{300}>{078}
{300}<{078}long description{300}>{078}
{300}<{078}description{300}>{078}
{300}<{078}actions{300}>
{300}<{078}affects{300}>
{300}<{078}alignment{300}> {078}S
{300}<{078}level{300}> <{078}body part{300}> <{078}attack part{300}> <{078}hitpoints ?d?+?{300}> <{078}damage ?d?+?{300}>
{300}<{078}gold{300}> <{078}race{300}>
{300}<{078}loaded position{300}> <{078}default position{300}> <{078}sex{300}>
{300}[{078}mob program{300}]
{300}
{078}#0
~

95 BLUEPRINTS4~
{300}
{078}#OBJECTS
{300}
{300}<{078}#vnum{300}>
{300}<{078}name list{300}>{078}
{300}<{078}short description{300}>{078}
{300}<{078}long description{300}>{078}
{300}<{078}description{300}>{078}
{300}<{078}item type{300}>
{300}<{078}item flags{300}>
{300}<{078}wear locations{300}>
{300}<{078}value0{300}> <{078}value1{300}> <{078}value2{300}> <{078}value3{300}>
{300}<{078}weight{300}> <{078}cost{300}> <{078}level{300}>
{300}[{078}obj program{300}]

{078}E
{300}<{078}extra name list{300}>{078}
{300}<{078}extra description{300}>{078}

{078}A {300}<{078}apply type{300}> <{078}apply amount{300}>

{078}C
{300}<{078}attack message{300}>{078}
{300}<{078}classes that may use weapon{300}>
~

95 BLUEPRINTS5~
{300}
{078}#ROOMS
{300}
{300}<{078}#vnum{300}>
{300}<{078}room name{300}>{078}
{300}<{078}room description{300}>{078}
{300}<{078}area number{300}> <{078}room flags{300}> <{078}sector type{300}>
{300}
{078}F {300}<{078}vnum to fall to{300}> <{078}slope of cliff{300}> <{078}amount of feet{300}>
{300}
{078}E
{300}<{078}extra name list{300}>{078}
{300}<{078}extra description{300}>{078}
{078}
{078}D{300}<{078}exit direction{300}>
{300}<{078}exit description{300}>{078}
{300}<{078}door name{300}>{078}
{300}<{078}door flags{300}> <{078}key number{300}> <{078}vnum of connect room{300}>
{078}
{078}S
{078}
{078}#0
~

95 BLUEPRINTS6~
{300}
{078}#SHOPS

{300}<{078}vnum{300}> <{078}type0{300}> <{078}type1{300}> <{078}type2{300}> <{078}type3{300}> <{078}type4{300}> <{078}buy %{300}> <{078}sell %{300}> <{078}open{300}> <{078}close{300}>

{078}0
~

95 BLUEPRINTS7~
{300}
{078}#RESETS
{300}
{078}M {300}<{078}if-flag{300}>  <{078}mob vnum{300}> <{078}maximum{300}> <{078}room vnum{300}>
{078}G {300}<{078}if-flag{300}>  <{078}obj vnum{300}> <{078}maximum{300}>
{078}E {300}<{078}if-flag{300}>  <{078}obj vnum{300}> <{078}maximum{300}> <{078}wear location{300}>
{300}
{078}O {300}<{078}if-flag{300}>  <{078}obj vnum{300}> <{078}maximum{300}> <{078}room vnum{300}>
{078}P {300}<{078}if-flag{300}>  <{078}obj vnum{300}> <{078}maximum{300}> <{078}container vnum{300}>
{300}
{078}D {300}<{078}if-flag{300}> <{078}room vnum{300}> <{078}exit direction{300}> <{078}door flag{300}>
{300}
{078}R {300}<{078}if-flag{300}> <{078}room vnum{300}> <{078}last exit to randomize{300}>
{300}
{078}S
~

0 $~


#$

XXXXXXXXXX
#Savearea
